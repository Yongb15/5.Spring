 프레임워크라?
어플리케이션을 만들기 위한 기본적인 틀을 의미한다.
틀에 필요한 내용을 조립해서 쓰는 구조이다.

스프링 프레임워크
자바 플랫폼을 위한 어플리케이션 프레임워크로서 엔터프라이즈급 어플리케이션을 개발하기 위한 모든 기능을 
종합적으로 제공하는 경량화된 솔루션이다.
엔터프라이즈급 개발이란 뜻대로만 풀이하면 기업을 대상으로 하는 개발이라는 뜻이다.
대규모 처리와 트랜잭션이 동시에 여러 사용자로부터 행해지는 매우 큰 규모의 엔터프라이즈 환경을 뜻한다.

스프링 프레임워크의 특징
1. 의존성 주입(Dependency Injection)
- 사용자가 객체를 직접만들어 사용하는 것이 아니라, 만들어진 객체를 주입받아 사용을 한다.
예) 장난감은 배터리가 있어야 움직일수 있다 장난감은 배터리에 의존하고 있다.
장난감에 배터리를 넣어주는 행위를 의존성 주입이라고 할 수 있다.
각각의 계층이나 서비스들 간에 의존성이 필요한 경우 프레임워크가 서로 연결시켜준다.

2. 제어역행(Inversion of Control)
-제어의 흐름을 전통적인 방식과 다르게 뒤바꾸는 것


Car car = new Car();
car.turboDrive();
void turboDrive(){
Engine = new TurboEngine();
engine.start();
}

Car car = new Car();
car.drive(new SupeerEngine());

void drive(Engine engine){
	engine.start();
}

객체의 생명주기의 관리까지 모든 객체에 대한 제어권을 프레임워크가 가진다.
일반적인 상황에서는 개발자가 new 연산자를 통해 객체를 생성하고 직접 제어를 해야 했다.
Spring에서는 xml파일 또는 어노테이션 방식으로 스프링 컨테이너에 Bean을 등록하기만 하면된다.
Spring은 Bean객체의 생명주기(생성 -> 의존성 결정 -> 초기화 -> 소멸)를 전부 관리해준다.

Bean(빈)이란 무엇인가??
JavaBeans로부터 시작했다.
재사용이 가능한 컨포넌트 상태
GUI형태로 클라이언트 측에 보여주는 형태로 밀어주려고 했다.
한번 만들어 놓으면 다른 개발자들이 조금만 수정해서 사용하면 되기 때문이다.
자바가 서버측 언어로 곽광받기 시작하면서 Servlet & JspBean - MVC의 Model, EL,JspContainer가 관리를 하기 시작했다.

Spring Bean
POJO : Plane Old Java Object(순수 자바 객체)
필드와 Getter,Setter로 구성된 가장 순수한 형태의 클래스
스프링 컨테이너가 관리하는 객체

Spring Container
Bean의 저장소
Bean을 관리

Maven
자바용 프로젝트 관리 도구
pom.xml파일을 통해 정형화된 빌드 시스템으로 프로젝트를 관리해준다.
필요한  라이브러리를 pom.xml에 정의해 놓으면 내가 사용할 라이브러리 뿐만 아니라 해당 라이브러리가 작동하는 데에 필요한 다른 라이브러리들까지 관리하여 네트워크를 통해 자동으로 다운로드 해준다.
프로젝트의 전체적인 라이프 사이클을 관리한다.

빌드
프로젝트를 위해 작성한 java코드나 여러 자원들(.xml.jar)를 JVM이나 톰캣 같은 WAS가 인식할 수 있는 구조로 패키징 하는 과정 및 결과물이다.
또 단순한 컴파일 해주는 작업 뿐만 아니라 테스팅, 검사, 배포까지 일련의 작업을 통틀어서 빌드라고 한다.

pom.xml
Project Object Model의 약자로 프로젝트의 다양한 정보를 처리하기 위한 객체 모델이다.
pom.xml에는 프로젝트 관리 및 빌드에 필요한 환경 설정, 의존성  관리 등의 정보를 기술한다.

MVC 디자인패턴 이론
MVC는 Model, View, Controller의 약자로, 클라이언트와 상호작용하는 소프트웨어를 설계함에 있어 세가지 요소로 나누는 것을 말한다.

Model
Model은 어플리케이션의 정보, 데이터의 가공을 책임지며 데이터베이스와 상호작용하여 비즈니스 로직을 처리하는 모듈
사용자가 이용하려는 모든 데이터를 가지고 있어야한다.
View또는  Controller에 대한 어떤 정보도 알 수 없어야한다.
변경이 일어났을때 처리 방법을 구현해약한다.
모델은 재사용이 가능해야하며 다른 인터페이스에서도 변하지 않아야한다.


View
클라이언트 단에서 보여지는 결과화면을 반환하는 모듈
Model이 가지고 있는 데이터를 저장하면 안된다.
데이터를 받아 단순히 화면에 표시해주는 역할만 한다.
재사용이 가능하게끔 설계를 해야 하며 다른 정보들을 표현할 떄 쉽게 설계해야한다.
Controller
클라이언트로부터 요청이 들어왔을때 그 입력을 처리하고 어떤 로직을 실행 시킬지 Model과 View를 연결해주며 제어하는 모듈
Model또는 View에 대한 정보를 알아야한다.
Model 또는 view의 변경을 인지하여 대처해야 한다.
모델이나 뷰의 변경을 통지 받으면 이를 해석 해서 각각의 구성요소에 통지해야한다.
어플리케이션의 메인 로직을 담당한다.

객체 지향 설계 5대 원칙 - SOLID
1. 단일 책임 원칙(SRP, Single Responsibility Principle)
하나의 메서드는 하나의 관심사(책임)만 가져야 한다.

2. 개방 패쇄 원칙(OCP, Open-Closed Principle)
상속에는 Open, 변경에는 Close해야한다.
코드를 변경할 일이 있으면 변경하지 말고 웬만하면 상속을 통해 변경해라

3. 리스코프 치환원칙(LSP, Liskovc Subtitution Principle)
같은 조상의 다른 클래스로 바꿔도 동작해야 한다.(다형성)

4. 인터페이스 분리 원칙(ISP, Interfacer Segragation Principle)
유사한 인터페이스가 있더라도 목적이 다르면 분리해야 한다.

5. 의존관계 역전 원칙(DIP, Dependency Inversion Principle)
추상화에 의존한 코드를 작성해야 한다.
코드가 너무 구체적이면 변경에 불리하다.

의존성 주입(Dependency Injection)
각 객체간의 의존관계를 스프링 컨테이너가 개발자가 정의한 Bean등록 정보를 바탕으로 자동으로 주입해주는 기능

의존성 주입의 종류
-필드 주입(Field Injection)
-setter Injection
-생성자 주입(Constructor Injection)

의존자동주입
의존 대상을 설정 코드에서 직접 주입하지 않고 스프링이 자동으로 의존하는 빈 객체를 주입해주는 기능
스프링에서 의존 자동 주입을 설정하려면 @Autowired어노테이션을 사용한다.
자동 주입기능을 사용하면 스프링이 알아서 의존 객체를 찾아서 주입한다.

스프링 AOP
Aspect-Oriented Programming
(관점지향 프로그래밍)
공통 기능 구현과 핵심 기능 구현의 분리
반복되는 로직들을 모듈화 하여 필요할 때 호출해서 사용하는 방법
여러가지 객체에 공통적으로 적용할 수 있는 기능을 분리해 재사용성을 높이는 기법

AOP를 코딩하기 위한 개념
핵심 기능에 공통 기능을 삽입하며 다음과 같은 방법이 존재
실행될 때 프록시 객체를 생성해서 공통기능을 삽입
스프링 AOP는 프록시 객체를 자동으로 생성해준다.
AOP의 공통 기능을 Aspect라 칭하며, 아래와 같은 주요 용어가 존재

Target
적용시킬 로직
Advice
반복 로직의 구현체(언제 적용시킬거냐)
joinPoint
Advice를 적용 가능한 지점을 의미
PointCut
JoinPoint의 상세한 스펙을 정의한것
Weaving
Advice를 핵심 로직 코드에 적용하는 것
Aspect
반복되어 사용되는 로직

프록시 패턴
컴퓨터 프로그래밍 소프트웨어 디자인 패턴중 하나
다른 무언가와 이어지는 인터페이스 역할을 하는 클래스
어떤 객체에 대한 접근을 제어하는 용도로 대리인이나 대변인에 해당하는 객체를 제공하는 패턴

Advice의 종류
before Advice : 대상 객체의 메서드 호출 전에 공통 기능을 실행
After Returning Advice : 대상 객체의 메서드가 예외없이 실행된후 공통 기능을 실행
After Throwing Advice : 대상 객체의 메서드를 실행하는 중 예외가 발생한 경우 공통 기능을 실행
After Advice : 예외 발생 여부에 상관없이 대상 객체에 메서드 실행후 공통기능을 실행
Around Advice: 대상 객체의 메서드 실행 전, 후 또는 예외 발생 시점에 공통기능을 실행

단위 테스트
하나의 모듈을 기준으로 독립적으로 진행되는 가장 작은 테스트 단위
하나의 모듈이란 각 계층에서 하나의 기능 또는 메서드로 이해할 수 있다.
그 기능이 올바르게 동작하는지를 독립적으로 테스트하는 것

단위 테스트의 필요성
테스트 코드를 작성하는 것은 단위 테스트를 의미함

통합 테스트는 실제 여러 컴포넌트들 간의 상호작용을 테스트하기 때문에 모든 컴포넌트들이 구동된 상태에서 테스트를 하게 되므로 캐시나 데이터베이스 등 다른 컴포넌트들과 실제 연결을 해야하고 어플리케이션을 구성하는 컴포넌트들이 많아질수록 테스트를 위한 시간이 커진다.

단위 테스트는 테스트하고자 하는 부분만 독립적으로 테스트를 하기 때문에 해당 단위를 유지보수 또는 리팩토링 하더라도 빠르게 문제 여부를 확인할 수 있다.

단위 테스트의 한계
일반적으로 어플리케이션은 하나의 독립된 기능을 처리하기 위해 다른 객체들과 데이터를 주고받는 통신이 일어난다.
단위 테스트는 해당 기능에 대한 독립적인 테스트기 때문에 다른 객체와 데이터를 주고받는 경우에 문제가 발생한다.
이 문제를 해결하기 위해 테스트하고자 하는 기능과 연관된 모듈에서 가짜 데이터, 정해진 반환값이 필요함
단위 테스트에서는 테스트 하고자 하는 기능과 연관된 모듈은 연결이 일절 단절되어야 비로소 독립적인 단위 테스트가 가능함

log4jdbc.spylogdelegator.name=net.sf.log4jdbc.log.Slf4jSpyLogDelegator